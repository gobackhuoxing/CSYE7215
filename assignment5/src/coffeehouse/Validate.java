package coffeehouse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import coffeehouse.SimulationEvent;


/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		private static final long serialVersionUID = 1L;
		public InvalidSimulationException() { }
	}

	// Helper method for validating the simulation
	private static void check(boolean check, String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
			int numCustomers = 0; 
			int numCooks = 0;
			int numTables = 0; 
			int machineCapacity = 0;
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			check(events.get(events.size()-1).event == SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");
			
			//init params
			if(events.get(0).event == SimulationEvent.EventType.SimulationStarting) {
				int[] params = events.get(0).simParams;
				numCustomers = params[0];
				numCooks = params[1];
				numTables = params[2];
				machineCapacity = params[3] ;
			}
			
			//Should not have more eaters than specified
			List<SimulationEvent> customer = new ArrayList<SimulationEvent>();
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerStarting) {
					customer.add(event);
				}
			}
			check(customer.size()==numCustomers,
					"Simulation have wrong customer number");
			
			//Should not have more cooks than specified
			List<SimulationEvent> cooks = new ArrayList<SimulationEvent>();
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CookStarting) {
					cooks.add(event);
				}
			}
			check(cooks.size()==numCooks,
					"Simulation have wrong cook number");
			
			//The coffee shop capacity should not be exceeded
			int currentCustomer = 0;
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerEnteredCoffeeShop) {
					currentCustomer++;
				}
				else if(event.event==SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
					currentCustomer--;
				}
				check(currentCustomer<=numTables,
						"exceed coffee shop capacity");
			}
			
			//The capacity of each machine should not be exceeded
			int machineGrill = 0;
			int fryer = 0;
			int coffeeMaker2000 =0;
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.MachineStartingFood) {
					if(event.machine.machineName.equals("machineGrill")) machineGrill++;
					else if (event.machine.machineName.equals("fryer")) fryer++;
					else if (event.machine.machineName.equals("coffeeMaker2000")) coffeeMaker2000++;
				}
				else if(event.event==SimulationEvent.EventType.MachineDoneFood) {
					if(event.machine.machineName.equals("machineGrill")) machineGrill--;
					else if (event.machine.machineName.equals("fryer")) fryer--;
					else if (event.machine.machineName.equals("coffeeMaker2000")) coffeeMaker2000--;
				}
				
				check(machineGrill<=machineCapacity && fryer<=machineCapacity && coffeeMaker2000<=machineCapacity,
						"exceed machine capacity");
			}
			
			//Customer should receive the correct order
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerReceivedOrder) {
					if(event.orderNumber!=event.customer.getOrderNum()) {
						check(false,"Customer receive wrong order");
					}
				}
			}
			
			//Eater should not receive order until cook completes it
			ArrayList<Integer> completeOrder = new ArrayList<Integer>();
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CookCompletedOrder) completeOrder.add(event.orderNumber);
				else if (event.event==SimulationEvent.EventType.CustomerReceivedOrder) {
					boolean orderComplete= false;
					for (int orderNum:completeOrder) {
						if(orderNum==event.orderNumber) {
							orderComplete =true;
							break;
						}
					}
					check(orderComplete,"Customer received a unfinished order");
				}
			}
			
			//Eater should not leave coffee shop until order is received
			ArrayList<Customer> leavingCustomer = new ArrayList<Customer>();
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerReceivedOrder) leavingCustomer.add(event.customer);
				else if (event.event==SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
					boolean orderReceived= false;
					for (Customer cus:leavingCustomer) {
						if(cus.toString().equals(event.customer.toString())) {
							orderReceived =true;
							break;
						}
					}
					check(orderReceived,"Customer leave without receiveing order");
				}
			}
			
			//Eater should not place more than one order
			ArrayList<Customer> OrderedCustomer = new ArrayList<Customer>();
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerPlacedOrder) {
					if(OrderedCustomer.contains(event.customer)){
						check(false,"Customer place more than one order");
					}
					else OrderedCustomer.add(event.customer);
				}
			}
			
			//Cook should not work on order before it is placed
			ArrayList<Integer> Ordered = new ArrayList<Integer>();
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerPlacedOrder) Ordered.add(event.orderNumber);
				else if(event.event==SimulationEvent.EventType.CookReceivedOrder) {
					boolean orderReceived= false;
					for(int num: Ordered) {
						if(num==event.orderNumber) {
							orderReceived = true;
							break;
						}
					}
					check(orderReceived,"Cook receive order before it is placed");
				}
			}

			//all the items should be cooked before Cook finished order
			HashMap<Integer,int[]> list1 = new HashMap<Integer,int[]>();
			HashMap<Integer,List<Food>> list2 = new HashMap<Integer,List<Food>>();
			for(int i = 0; i<numCustomers; i++) {
				list1.put(i+1, new int[]{0,0,0});
			}
			boolean ordercooked = true;
			for(SimulationEvent event:events) {
				if(event.event==SimulationEvent.EventType.CustomerPlacedOrder) {
					list2.put(event.orderNumber, event.orderFood);
				}
				else if(event.event==SimulationEvent.EventType.CookFinishedFood) {
					switch(event.food.toString()) {
						case "burger" :
							list1.put(event.orderNumber, new int[] {
									list1.get(event.orderNumber)[0]+1,
									list1.get(event.orderNumber)[1],
									list1.get(event.orderNumber)[2]
							});
							break;
						case "fries" :
							list1.put(event.orderNumber, new int[] {
									list1.get(event.orderNumber)[0],
									list1.get(event.orderNumber)[1]+1,
									list1.get(event.orderNumber)[2]
							});
							break;
						case "coffee" : 
							list1.put(event.orderNumber, new int[] {
									list1.get(event.orderNumber)[0],
									list1.get(event.orderNumber)[1],
									list1.get(event.orderNumber)[2]+1
							});
							break;
					}
				}
				else if (event.event==SimulationEvent.EventType.CookCompletedOrder){
					int burger = 0;
					int fries = 0;
					int coffee = 0;
					for(Food food: list2.get(event.orderNumber)) {
						if(food.equals(FoodType.burger)) burger++;
						if(food.equals(FoodType.fries)) fries++;
						if(food.equals(FoodType.coffee)) coffee++;
					}
					if(list1.get(event.orderNumber)[0]!= burger || list1.get(event.orderNumber)[1]!= fries || list1.get(event.orderNumber)[2]!= coffee) {
						ordercooked = false;
					}
				}
			}
			check(ordercooked, "Cook finished order before all the items were cooked");
			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
